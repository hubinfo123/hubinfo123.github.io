---
title: 数组扁平化
date: 2023-01-28 19:30
tags: [JS]
categories: js 基础
excerpt: 数组扁平化常规处理方式。
---

<font face="STCAIYUN" size="2">新年伊始，第一天上班，依旧打卡比较早，习惯性的看看文章，于是看到了这样一篇文章《手写—数组扁平化》，过年在家休息了 10 多天，也想看看自己忘记了没有，于是将自己当时看到这篇文章时，自己的个人想法记录下来。</font>

<font face="STCAIYUN" size="2">遇到这样的题目时，首先不能基于就想方法解题，方法可能会有多种，但是出题者的目的是什么也可以稍微思考一下，然后在根据自己的思考，进行解答，我当时的理解就是首先要考的就是对常用 API 的使用和理解，其次就是不用 API 自己实现，最后就是如果出现多种实现方式，对不同实现方式的一个理解。</font>

<font face="STCAIYUN" size="4"><p>试题：[1, [2, [3, [4, 5]]]] ，将其扁平化输出[1,2,3,4,5]</p></font>

```
1. 从常用API 的使用来解：
首选es6 自带的flat 方法，flat(depth) 方法会按照一个可指定的递归深度递归遍历数组，
并将所有的元素与遍历的子数组中的元素进行合并，最后返回一个新的数组；
const arr = [1, [2, [3, [4, 5]]]];
arr.flat(4)
输出：[1,2,3,4,5]

depth 是可选参数，默认为1层，指要提取嵌套数组的结构深度；

arr.flat()
输出：[1,2,[3,[4,5]]]

如果数组深度未知，那么可以使用关键字进行无限递归，Infinity
arr.flat(Infinity)
输出：[1,2,3,4,5]

2. 手写数组扁平化
function myFlat(arr,depth){
  let result = [];
  if(!arr.length ){
    return result;
  }
  for(let i = 0; i<arr.length;i++){
    if(Array.isArray(arr[i]) && depth>0 ){
      result = result.concat(myFlat(arr[i],depth-1))
    }else{
      result.push(arr[i])
    }
  }
  return result;
}
const res = myFlat(arr,4);
输出：[1,2,3,4,5]
思考：这里如何去实现Infinity

3.使用非递归的方式实现：
function myFlat2(arr){
  if(!arr.length){
    return []
  }
  const result = [];
  let stack = [...arr]
  while(stack.length){
    const next = stack.pop();
    if(Array.isArray(next)){
      stack.push(...next);
    }else{
      result.push(next);
    }
  }
  return result.reverse();
}
const res = myFlat2(arr)
输出：[1,2,3,4,5]

```

<font face="STCAIYUN" size="2">在上面的解法中，我们使用了常用的递归与迭代循环，二者的区别是：
编程之美：“迭代是人，递归是神！”

递归：重复调用函数自身实现循环；
迭代：利用变量的原值推出新值，或着说迭代是函数内某段代码实现循环。
递推：是一种用若干步可重复的简运算（规律）来描述复杂问题的方法

我理解迭代和递推是一样的

递归实际上是不断地深层调用函数，直到函数有返回才会逐层的返回。递归是用栈机制实现的，每深入一层，都要占去一块栈数据区域，因此，递归涉及到运行时的堆栈开销（参数必须压入堆栈保存，直到该层函数调用返回为止，才出栈），所以有可能导致堆栈溢出的错误；但是递归编程所体现的思想正是人们追求简洁、将问题交给计算机，以及将大问题分解为相同小问题从而解决大问题的动机。

迭代大部分时候需要人为的对问题进行剖析，分析问题的规律所在，将问题转变为一次次的迭代来逼近答案。迭代不像递归那样对堆栈有一定的要求，另外一旦问题剖析完毕，就可以很容易的通过循环加以实现。迭代的效率高，但却不太容易理解，当遇到数据结构的设计时，比如图表、二叉树、网格等问题时，使用就比较困难，而是用递归就能省掉人工思考解法的过程，只需要不断的将问题分解直到返回就可以了。

两者关系：所有的迭代可以转换为递归，但递归不一定可以转换成迭代。</font>

<table>
    <th>
        </th><td>定义</td>
        <td>优点</td>
        <td>缺点</td>
    </th>
    <tr>
        <td>递归</td>
        <td>重复调用函数自身实现循环</td>
        <td> 1.用有限的循环语句实现无限集合；<br> 2.易读。</td>
        <td> 1.递归不断调用函数，浪费空间；<br> 2.容易造成堆栈溢出。</td>
    </tr>
    <tr>
        <td>迭代</td>
        <td>利用变量的原值推出新值<br>函数内某段代码实现循环</td>
        <td>1.效率高，运行时间值随循环的增加而增加；<br>2.无额外的开销。</td>
        <td>1.代码难理解；<br>2.不如递归简洁。</td>
    </tr>
    <tr>
        <td>二者关系</td>
        <td colspan="4"> 1.递归中一定有迭代，迭代中不一定有递归；大部分都可以相互转换；<br>2.相对递归的缺点来说，能用迭代不用递归（不断调用函数，浪费空间，容易造成堆栈溢出）。</td>
    </tr>
</table>
