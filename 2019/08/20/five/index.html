<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="miroku">
  <!-- Open Graph Data -->
  <meta property="og:title" content="React Hooks"/>
  <meta property="og:description" content="" />
  <meta property="og:site_name" content="tomorrow tomorrow tomorrow，ain`t no such thing as tomorrow！"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://yoursite.com"/>
  
    <link rel="alternate" href="/atom.xml" title="tomorrow tomorrow tomorrow，ain`t no such thing as tomorrow！" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>tomorrow tomorrow tomorrow，ain`t no such thing as tomorrow！</title>

  <!-- Bootstrap CSS -->
  
<link rel="stylesheet" href="/css/bootstrap.min.css">

  <!-- Custom CSS -->
  
  
<link rel="stylesheet" href="/css/style.light.css">


  <!-- Google Analytics -->
  

<meta name="generator" content="Hexo 5.4.2"></head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/banner.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">React Hooks</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  首页
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  归档
                  
                </a>
              </li>
            
              <li>
                <a target="_blank" rel="noopener" href="https://github.com/miroku-y">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="email:15967115901m0@sina.cn">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By miroku</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2019-08-20</span>
            <span class="time">00:20:33</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/react/">react</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/react-hooks/">#react-hooks</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <h6 id="1-什么是-Hooks"><a href="#1-什么是-Hooks" class="headerlink" title="1.什么是 Hooks"></a>1.什么是 Hooks</h6><h6 id="•-React-一直都提倡使用函数组件，但是有时候需要使用-state-或者其他一些功能时，只能使用类组件，因为函数组件没有实例，没有生命周期函数，只有类组件才有"><a href="#•-React-一直都提倡使用函数组件，但是有时候需要使用-state-或者其他一些功能时，只能使用类组件，因为函数组件没有实例，没有生命周期函数，只有类组件才有" class="headerlink" title="• React 一直都提倡使用函数组件，但是有时候需要使用 state 或者其他一些功能时，只能使用类组件，因为函数组件没有实例，没有生命周期函数，只有类组件才有"></a>• React 一直都提倡使用函数组件，但是有时候需要使用 state 或者其他一些功能时，只能使用类组件，因为函数组件没有实例，没有生命周期函数，只有类组件才有</h6><h6 id="•-Hooks-是-React-16-8-新增的特性，它可以让你在不编写-class-的情况下使用-state-以及其他的-React-特性"><a href="#•-Hooks-是-React-16-8-新增的特性，它可以让你在不编写-class-的情况下使用-state-以及其他的-React-特性" class="headerlink" title="• Hooks 是 React 16.8 新增的特性，它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性"></a>• Hooks 是 React 16.8 新增的特性，它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性</h6><h6 id="•-如果你在编写函数组件并意识到需要向其添加一些-state，以前的做法是必须将其它转化为-class。现在你可以直接在现有的函数组件中使用-Hooks"><a href="#•-如果你在编写函数组件并意识到需要向其添加一些-state，以前的做法是必须将其它转化为-class。现在你可以直接在现有的函数组件中使用-Hooks" class="headerlink" title="• 如果你在编写函数组件并意识到需要向其添加一些 state，以前的做法是必须将其它转化为 class。现在你可以直接在现有的函数组件中使用 Hooks"></a>• 如果你在编写函数组件并意识到需要向其添加一些 state，以前的做法是必须将其它转化为 class。现在你可以直接在现有的函数组件中使用 Hooks</h6><h6 id="•-凡是-use-开头的-React-API-都是-Hooks"><a href="#•-凡是-use-开头的-React-API-都是-Hooks" class="headerlink" title="• 凡是 use 开头的 React API  都是 Hooks"></a>• 凡是 use 开头的 React API  都是 Hooks</h6><h6 id="2-Hooks-解决的问题"><a href="#2-Hooks-解决的问题" class="headerlink" title="2.Hooks 解决的问题"></a>2.Hooks 解决的问题</h6><blockquote>
<ol>
<li>类组件的不足</li>
</ol>
</blockquote>
<h6 id="•-状态逻辑难复用：在组件之间复用状态逻辑很难，可能要用到-render-props-（渲染属性）或者-HOC（高阶组件），但无论是渲染属性，还是高阶组件，都会在原先的组件外包裹一层父容器（一般都是-div-元素），导致层级冗余、趋向复杂难以维护"><a href="#•-状态逻辑难复用：在组件之间复用状态逻辑很难，可能要用到-render-props-（渲染属性）或者-HOC（高阶组件），但无论是渲染属性，还是高阶组件，都会在原先的组件外包裹一层父容器（一般都是-div-元素），导致层级冗余、趋向复杂难以维护" class="headerlink" title="• 状态逻辑难复用：在组件之间复用状态逻辑很难，可能要用到 render props （渲染属性）或者 HOC（高阶组件），但无论是渲染属性，还是高阶组件，都会在原先的组件外包裹一层父容器（一般都是 div 元素），导致层级冗余、趋向复杂难以维护"></a>• 状态逻辑难复用：在组件之间复用状态逻辑很难，可能要用到 render props （渲染属性）或者 HOC（高阶组件），但无论是渲染属性，还是高阶组件，都会在原先的组件外包裹一层父容器（一般都是 div 元素），导致层级冗余、趋向复杂难以维护</h6><h6 id="•-在生命周期函数中混杂不相干的逻辑（如：在-componentDidMount-中注册事件以及其他的逻辑，在-componentWillUnmount-中卸载事件，这样分散不集中的写法，很容易写出-bug-）"><a href="#•-在生命周期函数中混杂不相干的逻辑（如：在-componentDidMount-中注册事件以及其他的逻辑，在-componentWillUnmount-中卸载事件，这样分散不集中的写法，很容易写出-bug-）" class="headerlink" title="• 在生命周期函数中混杂不相干的逻辑（如：在 componentDidMount 中注册事件以及其他的逻辑，在 componentWillUnmount 中卸载事件，这样分散不集中的写法，很容易写出 bug ）"></a>• 在生命周期函数中混杂不相干的逻辑（如：在 componentDidMount 中注册事件以及其他的逻辑，在 componentWillUnmount 中卸载事件，这样分散不集中的写法，很容易写出 bug ）</h6><h6 id="•-类组件中到处都是对状态的访问和处理，导致组件难以拆分成更小的组件"><a href="#•-类组件中到处都是对状态的访问和处理，导致组件难以拆分成更小的组件" class="headerlink" title="• 类组件中到处都是对状态的访问和处理，导致组件难以拆分成更小的组件"></a>• 类组件中到处都是对状态的访问和处理，导致组件难以拆分成更小的组件</h6><h6 id="•-this-指向问题：父组件给子组件传递函数时，必须绑定-this"><a href="#•-this-指向问题：父组件给子组件传递函数时，必须绑定-this" class="headerlink" title="• this 指向问题：父组件给子组件传递函数时，必须绑定 this"></a>• this 指向问题：父组件给子组件传递函数时，必须绑定 this</h6><h6 id="•-react-中的组件四种绑定-this-方法的区别"><a href="#•-react-中的组件四种绑定-this-方法的区别" class="headerlink" title="• react 中的组件四种绑定 this 方法的区别"></a>• react 中的组件四种绑定 this 方法的区别</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class App extends React.Component&lt;any, any&gt; &#123;</span><br><span class="line">    handleClick2;</span><br><span class="line"></span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            num: 1,</span><br><span class="line">            title: &#x27; react study&#x27;</span><br><span class="line">        &#125;;</span><br><span class="line">        this.handleClick2 = this.handleClick1.bind(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleClick1() &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            num: this.state.num + 1,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleClick3 = () =&gt; &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            num: this.state.num + 1,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (&lt;div&gt;</span><br><span class="line">            &lt;h2&gt;Ann, &#123;this.state.num&#125;&lt;/h2&gt;</span><br><span class="line">            &lt;button onClick=&#123;this.handleClick2&#125;&gt;btn1&lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;this.handleClick1.bind(this)&#125;&gt;btn2&lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; this.handleClick1()&#125;&gt;btn3&lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;this.handleClick3&#125;&gt;btn4&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>子组件内部做了性能优化，如（React.PureComponent）</p>
</blockquote>
<h6 id="•-第一种是在构造函数中绑定-this：那么每次父组件刷新的时候，如果传递给子组件其他的-props-值不变，那么子组件就不会刷新；"><a href="#•-第一种是在构造函数中绑定-this：那么每次父组件刷新的时候，如果传递给子组件其他的-props-值不变，那么子组件就不会刷新；" class="headerlink" title="• 第一种是在构造函数中绑定 this：那么每次父组件刷新的时候，如果传递给子组件其他的 props 值不变，那么子组件就不会刷新；"></a>• 第一种是在构造函数中绑定 this：那么每次父组件刷新的时候，如果传递给子组件其他的 props 值不变，那么子组件就不会刷新；</h6><h6 id="•-第二种是在-render-函数里面绑定-this：因为-bind-函数会返回一个新的函数，所以每次父组件刷新时，都会重新生成一个函数，即使父组件传递给子组件其他的-props-值不变，子组件每次都会刷新；"><a href="#•-第二种是在-render-函数里面绑定-this：因为-bind-函数会返回一个新的函数，所以每次父组件刷新时，都会重新生成一个函数，即使父组件传递给子组件其他的-props-值不变，子组件每次都会刷新；" class="headerlink" title="• 第二种是在 render() 函数里面绑定 this：因为 bind 函数会返回一个新的函数，所以每次父组件刷新时，都会重新生成一个函数，即使父组件传递给子组件其他的 props 值不变，子组件每次都会刷新；"></a>• 第二种是在 render() 函数里面绑定 this：因为 bind 函数会返回一个新的函数，所以每次父组件刷新时，都会重新生成一个函数，即使父组件传递给子组件其他的 props 值不变，子组件每次都会刷新；</h6><h6 id="•-第三种是使用箭头函数：父组件刷新的时候，即使两个箭头函数的函数体是一样的，都会生成一个新的箭头函数，所以子组件每次都会刷新；"><a href="#•-第三种是使用箭头函数：父组件刷新的时候，即使两个箭头函数的函数体是一样的，都会生成一个新的箭头函数，所以子组件每次都会刷新；" class="headerlink" title="• 第三种是使用箭头函数：父组件刷新的时候，即使两个箭头函数的函数体是一样的，都会生成一个新的箭头函数，所以子组件每次都会刷新；"></a>• 第三种是使用箭头函数：父组件刷新的时候，即使两个箭头函数的函数体是一样的，都会生成一个新的箭头函数，所以子组件每次都会刷新；</h6><h6 id="•-第四种是使用类的静态属性：原理和第一种方法差不多，比第一种更简洁"><a href="#•-第四种是使用类的静态属性：原理和第一种方法差不多，比第一种更简洁" class="headerlink" title="• 第四种是使用类的静态属性：原理和第一种方法差不多，比第一种更简洁"></a>• 第四种是使用类的静态属性：原理和第一种方法差不多，比第一种更简洁</h6><blockquote>
<p>综上所述，如果不注意的话，很容易写成第三种写法，导致性能上有所损耗。</p>
</blockquote>
<blockquote>
<ol start="2">
<li>Hooks 优势</li>
</ol>
</blockquote>
<h6 id="•-能优化类组件的三大问题"><a href="#•-能优化类组件的三大问题" class="headerlink" title="• 能优化类组件的三大问题"></a>• 能优化类组件的三大问题</h6><h6 id="•-能在无需修改组件结构的情况下复用状态逻辑（自定义-Hooks-）"><a href="#•-能在无需修改组件结构的情况下复用状态逻辑（自定义-Hooks-）" class="headerlink" title="• 能在无需修改组件结构的情况下复用状态逻辑（自定义 Hooks ）"></a>• 能在无需修改组件结构的情况下复用状态逻辑（自定义 Hooks ）</h6><h6 id="•-能将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）"><a href="#•-能将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）" class="headerlink" title="• 能将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）"></a>• 能将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）</h6><h6 id="•-副作用的关注点分离：副作用指那些没有发生在数据向视图转换过程中的逻辑，如-ajax-请求、访问原生-dom-元素、本地持久化缓存、绑定-解绑事件、添加订阅、设置定时器、记录日志等。以往这些副作用都是写在类组件生命周期函数中的。而-useEffect-在全部渲染完毕后才会执行，useLayoutEffect-会在浏览器-layout-之后，painting-之前执行。"><a href="#•-副作用的关注点分离：副作用指那些没有发生在数据向视图转换过程中的逻辑，如-ajax-请求、访问原生-dom-元素、本地持久化缓存、绑定-解绑事件、添加订阅、设置定时器、记录日志等。以往这些副作用都是写在类组件生命周期函数中的。而-useEffect-在全部渲染完毕后才会执行，useLayoutEffect-会在浏览器-layout-之后，painting-之前执行。" class="headerlink" title="• 副作用的关注点分离：副作用指那些没有发生在数据向视图转换过程中的逻辑，如 ajax 请求、访问原生 dom 元素、本地持久化缓存、绑定/解绑事件、添加订阅、设置定时器、记录日志等。以往这些副作用都是写在类组件生命周期函数中的。而 useEffect 在全部渲染完毕后才会执行，useLayoutEffect 会在浏览器 layout 之后，painting 之前执行。"></a>• 副作用的关注点分离：副作用指那些没有发生在数据向视图转换过程中的逻辑，如 ajax 请求、访问原生 dom 元素、本地持久化缓存、绑定/解绑事件、添加订阅、设置定时器、记录日志等。以往这些副作用都是写在类组件生命周期函数中的。而 useEffect 在全部渲染完毕后才会执行，useLayoutEffect 会在浏览器 layout 之后，painting 之前执行。</h6>
        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          @2018-2023
        </p>
        <p class="copyright text-muted">
          让花成花 让树成树
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->

<script src="/js/highlight.pack.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

